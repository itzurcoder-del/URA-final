<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>URA â€” Chat with memory</title>
<style>
  :root{
    --bg:#f5f7fb; --panel:#fff; --muted:#6b7280; --accent:#06b6d4; --bot:#22c55e; --user:#0ea5e9;
  }
  body{font-family:Inter,system-ui,Arial; margin:0;height:100vh;background:#ecf0f3;color:#111; display:flex;}
  /* sidebar */
  #sidebar{width:260px;background:var(--panel);box-shadow:2px 0 12px rgba(12,12,12,0.06);padding:12px;display:flex;flex-direction:column;gap:8px}
  #brand{font-weight:700;padding:6px 2px} 
  #signinBtn, #signoutBtn{padding:8px;border-radius:8px;border:none;background:var(--accent);color:#000;cursor:pointer}
  #chatsList{flex:1; overflow:auto; margin-top:6px; display:flex; flex-direction:column; gap:6px}
  .chat-item{padding:10px;border-radius:10px;cursor:pointer;color:#111}
  .chat-item.active{background:#eef8ff}
  #newChat{padding:8px;border-radius:8px;border:1px dashed #ddd;background:transparent;cursor:pointer}
  /* main */
  #main{flex:1;display:flex;flex-direction:column}
  header{height:64px;display:flex;align-items:center;justify-content:space-between;padding:0 18px;background:transparent}
  header h1{margin:0;font-size:18px}
  #chat{flex:1;padding:18px;overflow:auto;display:flex;flex-direction:column;gap:12px}
  .msg{max-width:72%;padding:10px 14px;border-radius:14px;word-wrap:break-word;line-height:1.4;position:relative}
  .msg.bot{align-self:flex-start;background:var(--bot);color:#fff}
  .msg.user{align-self:flex-end;background:var(--user);color:#000}
  .controls{display:flex;gap:10px;padding:14px;border-top:1px solid #e6eef6;align-items:center;background:transparent}
  textarea{flex:1;height:48px;padding:12px;border-radius:999px;border:1px solid #e6eef6;outline:none;resize:none}
  button{background:var(--accent);border:none;padding:10px 12px;border-radius:12px;cursor:pointer}
  .small{padding:6px 8px;border-radius:8px}
  .msg-controls{margin-top:8px;display:flex;gap:8px}
  /* modal */
  #loginModal{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35)}
  #loginCard{background:#fff;padding:20px;border-radius:12px;max-width:420px;width:90%;box-shadow:0 10px 30px rgba(0,0,0,0.15)}
  #loginCard h3{margin:0 0 10px 0}
  /* tiny */
  .muted{color:var(--muted);font-size:13px}
  .title-row{display:flex;align-items:center;justify-content:space-between;gap:8px}
  /* responsive */
  @media(max-width:880px){ #sidebar{display:none} }
</style>
</head>
<body>
  <!-- Sidebar -->
  <div id="sidebar">
    <div id="brand">URA â€” Chats</div>

    <div class="title-row">
      <div class="muted">Chats</div>
      <button id="newChat" class="small">+ New</button>
    </div>

    <div id="chatsList"></div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="signinBtn">Sign in with Google</button>
      <button id="signoutBtn" style="display:none;background:#ef4444;color:#fff">Sign out</button>
    </div>

    <div class="muted" style="font-size:12px;margin-top:10px">Signed in: <span id="userEmail">not signed</span></div>
  </div>

  <!-- Main -->
  <div id="main">
    <header>
      <h1>URA â€” Your assistant</h1>
      <div class="muted">Voice: <select id="voiceSelect" style="margin-left:8px"></select></div>
    </header>

    <div id="chat"></div>

    <div class="controls">
      <button id="micBtn" title="Speak">ðŸŽ¤</button>
      <textarea id="input" placeholder="Type your message... (Press Enter)"></textarea>
      <button id="sendBtn">Send</button>
    </div>
  </div>

  <!-- Login modal (optional) -->
  <div id="loginModal" style="display:none">
    <div id="loginCard">
      <h3>Sign in to save your chats</h3>
      <p class="muted">Sign in with Google to store chat history across devices. If you skip, memory will reset on refresh.</p>
      <div style="display:flex;gap:8px;margin-top:14px">
        <button id="modalSignIn" style="flex:1;background:#06b6d4">Sign in with Google</button>
        <button id="modalSkip" style="flex:1;background:#e6eef6;color:#000">Skip</button>
      </div>
    </div>
  </div>

<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
/* =========================
   CONFIG â€” EDIT THESE
   =========================
   1) Put your Firebase config below (go to Firebase console -> project -> web setup)
   2) Put your GROQ API key below (or change to call your server endpoint)
*/
const firebaseConfig = {
  apiKey: "AIzaSyAfbJJEw61oIaMKUIFMGVK062g376dSrXI",
  authDomain: "ura-ai-b1b20.firebaseapp.com",
  projectId: "ura-ai-b1b20",
  storageBucket: "ura-ai-b1b20.firebasestorage.app",
  messagingSenderId: "330104435643",
  appId: "1:330104435643:web:6f1d6f338a2e0de6cb0a9e"
};

const GROQ_API_KEY = "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"; // replace with your Groq key if calling Groq directly

/* =========================
   End config
   ========================= */

// init firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

// UI refs
const chatsListEl = document.getElementById("chatsList");
const chatEl = document.getElementById("chat");
const inputEl = document.getElementById("input");
const sendBtn = document.getElementById("sendBtn");
const micBtn = document.getElementById("micBtn");
const signInBtn = document.getElementById("signinBtn");
const signOutBtn = document.getElementById("signoutBtn");
const userEmailEl = document.getElementById("userEmail");
const modal = document.getElementById("loginModal");
const modalSignIn = document.getElementById("modalSignIn");
const modalSkip = document.getElementById("modalSkip");
const newChatBtn = document.getElementById("newChat");
const voiceSelect = document.getElementById("voiceSelect");

// app state
let user = null;               // firebase user
let chats = [];                // list of chat meta for sidebar: { id, title, updatedAt }
let activeChatId = null;       // selected chat doc id
let activeMessages = [];       // messages for active chat {role, text, ts}
let localModeTemp = { chats: [] }; // temporary memory when not signed in

// speech / voices
let voices = [];
function loadVoices(){ voices = speechSynthesis.getVoices() || []; voiceSelect.innerHTML = voices.map((v,i)=>`<option value="${i}">${v.name}</option>`).join(''); }
speechSynthesis.onvoiceschanged = loadVoices;
loadVoices();

// utility: format bold **text**
function formatTextHtml(t){ return t.replace(/\*\*(.*?)\*\*/g, "<b>$1</b>").replace(/\n/g,'<br>'); }

// UI helpers
function clearChatUI(){ chatEl.innerHTML = ''; }
function renderMessages(list){
  clearChatUI();
  list.forEach(m=>{
    const d = document.createElement('div');
    d.className='msg '+(m.role==='user'?'user':'bot');
    d.innerHTML = formatTextHtml(m.text);
    // if bot add controls
    if(m.role === 'assistant' || m.role === 'bot'){
      const controls = document.createElement('div'); controls.className='msg-controls';
      const read = document.createElement('button'); read.className='small'; read.textContent='ðŸ”Š Read'; read.onclick=()=> speak(m.text);
      const stop = document.createElement('button'); stop.className='small'; stop.textContent='â¹ Stop'; stop.onclick=()=> speechSynthesis.cancel();
      controls.append(read, stop);
      d.appendChild(controls);
    }
    chatEl.appendChild(d);
  });
  chatEl.scrollTop = chatEl.scrollHeight;
}

// sidebar render
function renderSidebar(){
  chatsListEl.innerHTML='';
  const list = user ? chats : localModeTemp.chats;
  list.forEach(c=>{
    const item = document.createElement('div');
    item.className='chat-item';
    if(c.id === activeChatId) item.classList.add('active');
    item.textContent = c.title || 'Untitled';
    item.onclick = ()=> openChat(c.id);
    chatsListEl.appendChild(item);
  });
}

// open chat by id (if local mode, id is index)
async function openChat(id){
  activeChatId = id;
  activeMessages = [];
  renderSidebar();
  if(user){
    // fetch from Firestore
    const doc = await db.collection('users').doc(user.uid).collection('chats').doc(id).get();
    if(!doc.exists) return;
    const data = doc.data();
    activeMessages = data.messages || [];
    renderMessages(activeMessages);
  } else {
    const idx = id;
    activeMessages = localModeTemp.chats[idx]?.messages || [];
    renderMessages(activeMessages);
  }
}

// create new chat
async function createNewChat(title = 'New chat'){
  if(user){
    const docRef = await db.collection('users').doc(user.uid).collection('chats').add({
      title,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
      messages: []
    });
    chats.unshift({ id: docRef.id, title });
    activeChatId = docRef.id;
    activeMessages = [];
    renderSidebar();
    renderMessages(activeMessages);
  } else {
    // local mode: push to temp array
    const idx = localModeTemp.chats.unshift({ title, messages: [] }) - 1;
    activeChatId = 0;
    activeMessages = [];
    renderSidebar();
    renderMessages(activeMessages);
  }
}

// append message to active chat and save
async function appendMessageToActive(role, text){
  const msg = { role: role === 'user' ? 'user' : 'assistant', text, ts: Date.now() };
  activeMessages.push(msg);
  renderMessages(activeMessages);

  if(user){
    // update Firestore doc
    const docRef = db.collection('users').doc(user.uid).collection('chats').doc(activeChatId);
    await docRef.update({
      messages: firebase.firestore.FieldValue.arrayUnion(msg),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    });
    // update sidebar local copy
    const found = chats.find(c=>c.id===activeChatId);
    if(found) found.updatedAt = new Date();
    renderSidebar();
  } else {
    // local temp
    if(!localModeTemp.chats[activeChatId]) localModeTemp.chats[activeChatId] = { title:'New chat', messages:[] };
    localModeTemp.chats[activeChatId].messages = activeMessages;
    renderSidebar();
  }
}

// ask Groq (client-side). If you'd rather hide key use /api/chat server route and remove GROQ_API_KEY here.
async function askGroq(prompt){
  if(!GROQ_API_KEY || GROQ_API_KEY === "YOUR_GROQ_API_KEY"){
    return "Groq API key not set. Replace GROQ_API_KEY in the HTML with your key or set up a server endpoint.";
  }

  const endpoint = "https://api.groq.com/openai/v1/chat/completions";
  const payload = {
    model: "llama-3.3-70b-versatile", // <-- pick a supported model in your Groq console; update if needed
    messages: [
      { role: "system", content: "You are URA, a helpful assistant. Always call yourself URA and be polite." },
      ...activeMessages.map(m => ({ role: m.role === 'user' ? 'user' : 'assistant', content: m.text })),
      { role: "user", content: prompt }
    ],
    max_tokens: 512,
    temperature: 0.7
  };

  const res = await fetch(endpoint, {
    method: "POST",
    headers: {
      "Content-Type":"application/json",
      "Authorization": `Bearer ${GROQ_API_KEY}`
    },
    body: JSON.stringify(payload)
  });

  if(!res.ok){
    const errText = await res.text();
    console.error("Groq API error:", errText);
    throw new Error("Groq API error");
  }
  const data = await res.json();
  // adapt depending on response shape
  const reply = data.choices?.[0]?.message?.content || data.choices?.[0]?.text || "No reply.";
  return reply;
}

/* ========== Main chat flow ========== */
async function sendChatText(text, speakIfVoice = false){
  // ensure an active chat exists
  if(activeChatId === null){
    await createNewChat("Chat");
  }
  // user message locally and saved
  await appendMessageToActive('user', text);

  // show thinking placeholder
  await appendMessageToActive('assistant', 'â€¦thinkingâ€¦');

  try{
    const reply = await askGroq(text);
    // remove last thinking entry (it was assistant)
    activeMessages = activeMessages.filter(m => m.text !== 'â€¦thinkingâ€¦' || m.role !== 'assistant');
    // append assistant actual reply
    await appendMessageToActive('assistant', reply);
    if(speakIfVoice) speak(reply);
  }catch(err){
    console.error(err);
    // replace thinking with error
    activeMessages = activeMessages.filter(m => m.text !== 'â€¦thinkingâ€¦' || m.role !== 'assistant');
    await appendMessageToActive('assistant', 'Error contacting Groq API.');
  }
}

// voice speak helper
async function waitForVoices(){
  return new Promise(resolve=>{
    let v = speechSynthesis.getVoices();
    if(v && v.length) return resolve(v);
    speechSynthesis.onvoiceschanged = ()=> resolve(speechSynthesis.getVoices());
  });
}
async function speak(text){
  const all = await waitForVoices();
  const v = all[voiceSelect.value] || all.find(x=>x.lang && x.lang.includes('en-GB')) || all[0];
  const u = new SpeechSynthesisUtterance(text.replace(/\*\*/g,''));
  if(v) u.voice = v;
  speechSynthesis.cancel();
  speechSynthesis.speak(u);
}

/* ========== UI events ========== */
sendBtn.onclick = ()=> {
  const t = inputEl.value.trim();
  if(!t) return;
  inputEl.value = '';
  sendChatText(t, false);
};
inputEl.addEventListener('keydown', e => {
  if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendBtn.click(); }
});

// mic
let recognition;
micBtn.onclick = async () => {
  if(!('webkitSpeechRecognition' in window)){
    alert('Speech recognition not supported in this browser.');
    return;
  }
  if(!recognition){
    recognition = new webkitSpeechRecognition();
    recognition.lang = 'en-GB';
    recognition.interimResults = false;
    recognition.onresult = e => {
      const txt = e.results[0][0].transcript;
      sendChatText(txt, true);
    };
    recognition.onstart = ()=> micBtn.textContent = 'ðŸŽ™ï¸';
    recognition.onend = ()=> micBtn.textContent = 'ðŸŽ¤';
  }
  recognition.start();
};

// create new chat
newChatBtn.onclick = ()=> createNewChat('New chat');

// modal actions
modalSignIn.onclick = ()=> signInWithGoogle();
modalSkip.onclick = ()=> { modal.style.display='none'; };

// sign-in
async function signInWithGoogle(){
  const provider = new firebase.auth.GoogleAuthProvider();
  try{
    const result = await auth.signInWithPopup(provider);
    // user will be set by onAuthStateChanged listener
    modal.style.display='none';
  }catch(err){
    console.error("Signin error", err);
    alert("Sign in failed: " + err.message);
  }
}

signInBtn.onclick = signInWithGoogle;
signOutBtn.onclick = ()=> auth.signOut();

/* ========== Auth listener ========= */
auth.onAuthStateChanged(async u => {
  user = u;
  if(user){
    // show sign out
    signInBtn.style.display='none';
    signOutBtn.style.display='inline-block';
    userEmailEl.textContent = user.email || user.displayName || user.uid;
    modal.style.display = 'none';
    // load chats from firestore
    const snap = await db.collection('users').doc(user.uid).collection('chats').orderBy('updatedAt','desc').get();
    chats = snap.docs.map(doc => ({ id: doc.id, title: (doc.data().title||'Chat'), updatedAt: doc.data().updatedAt?.toDate?.() || new Date() }));
    // open latest if exists
    if(chats.length) activeChatId = chats[0].id;
    renderSidebar();
    if(activeChatId) openChat(activeChatId);
  } else {
    // not signed in
    signInBtn.style.display='inline-block';
    signOutBtn.style.display='none';
    userEmailEl.textContent = 'not signed';
    // show modal to prompt sign-in
    modal.style.display = 'flex';
    // reset chats to empty local mode
    localModeTemp = { chats: [] };
    chats = [];
    activeChatId = null;
    activeMessages = [];
    renderSidebar();
    clearChatUI();
  }
});

/* ========== initial stubs ========== */
// make a quick starter chat in local mode
localModeTemp.chats.push({ title: 'Welcome', messages: [{ role:'assistant', text: 'Hello â€” I am URA. Sign in to save chats, or skip to try temporary chat.' }] });
activeChatId = 0;
openChat(activeChatId);

// load voices into dropdown when available
setTimeout(()=>loadVoices(), 500);
</script>
</body>
</html>
